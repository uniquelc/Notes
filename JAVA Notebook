1、JAVA注释

  * 第一种：
    //单行注释

  * 第二种：
    /*
        多
        行
        注
        释
    */

  * 第三种：
    /**
    *   多
    *   行
    *   注
    *   释
    */
【这种为比较专业的注释可以被javadoc.exe提取为帮助文档】

2、标识符命名规范

  * 最好见名知意
  * 遵守驼峰命名方式
      SystemService
      UserService
  * 类名、接口名：首字母大写，后面每个单词字母大写。
  * 变量名、方法名：首字母小写，后面每个单词首字母大写。
  * 常量名：全部大写。

3、JAVA中单引号和双引号

 * JAVA中字符串型字面值需用双引号括起来
 * JAVA中字符型字面值需用单引号括起来
 
4、关于JAVA中的变量与数据类型

 * 变量本质上来说是内存中的一块空间，这块空间有数据类型、有名字、有字面值。
 * 变量包含三部分：数据类型、名称、字面值【数据】
 * 变量是内存中储存数据的剧基本单元
 * 数据类型是指导程序在运行阶段应该分配多大的内存空间，不同的数据类型底层会分配不同大小的空间。
 
5、八种数据类型在全局变量的默认值
 
 * 数据类型在全局变量中如果不赋值，那么将赋予默认值：
   数据类型                      默认值
   -----------------------------------
   byte short int long          0
   float double                 0.0
   boolean                      false
   char                         \u0000

6、++i和i++的区别
 
 * ++出现在变量后【i++】
 * 规则：先做赋值运算，再做自加1运算。
 int a = 100;
 int b = a ++;
 System.out.println(a); //101
 System.out.println(b); //100
 
 * ++出现在变量前【++i】
 * 规则：先进行自加1运算，然后在进行赋值操作。
 int a = 100;
 int b = ++ a;
 System.out.println(a) //101
 System.out.println(b) //101
 
7、逻辑与&和短路与&&

 * int x = 10;
   int y = 8;
   System.out.println( x < y & ++x < y );
   System.out.println(x); //11
 * int x = 10;
   int y = 8;
   System.out.println( x < y && ++x < y );
   System.out.println(x); //10
   //后面的表达式没有执行，这种现象被称为短路现象
 
 * 第一个表达式的执行结果为fasle，会发生短路与。
 * 第一个表达式的执行结果为ture，会发生短路或。
 
8、关于类的说明
 public class MethodText{ //表示一个公开的类，起名为MethodText,由于是公开的，所以源文件名必须是：MethodText(与类名相同)
     //类体
     //类体中不能直接编写java语句，除声明变量之外
     //方法出现在类体当中

     //方法
     //public表示公开的
     //static表示静态的
     //void表示方法执行结束后不返回任何数据
     //main是方法名：主方法
     //(String[] args):形式参数列表，其中String[]是一种引用数据类型，args是一个局部变量的变量名
     //主方法就要这样写，这是程序的入口，程序都是从入口开始执行的。
     public static void main(String[] args){
     }
     public static void m(){
         for(int i = 0; i < 10; i++){
             if(i == 5){
                 return; //终止的是m()方法。如果为break，则终止的是for循环。
             }
         }
     }
 }

9、方法在执行过程当中，在JVM中的内存是如何分配的了，内存是如何变化的了？
    * 方法只定义，不调用，是不会执行的，并且在JVM中也不会给该方法分配“运行所属”的内存空间。
    * 在JVM内存划分上有这样三块“主要”的内存空间：
        * 方法区内存
        * 堆内存
        * 栈内存
    * 方法代码片段存在哪里？方法执行的时候执行过程的内存在哪里分配？
        * 方法代码片段属于.class字节码文件的一部分，字节码文件在类加载的时候，将其反到了方法区当中。所以JVM中的三块主要的内存空间中方法区内存最先有数据。存放了代码片段。
        * 代码片段虽然在方法区内存中只有一份，但是可以被重复使用。每一次调用这个方法的时候，需要给该方法分配独立的活动场所，在栈内存中分配。
    * 局部变量在栈中存储，局部变量在“方法体”中声明。
10、面向对象与面向过程
    - C语言是纯面向过程的，Java是纯面向对象的，C++是半面向对象的。
    - 面相对象：主要关注点是【独立体】能完成哪些功能。例：独立显卡（面向对象）和集成显卡（面向过程）。
     * 优点：耦合度低，扩展力强。更容易解决现实世界当中更复杂的业务逻辑。组件复用性强。
     * 缺点：前期投入成本较高，需要进行独立体的抽取，大量的系统分析与设计。
    - 面向过程：主要关注点是实现的具体过程，因果关系。
     * 优点：对于业务逻辑比较简单的程序，可以快速开发，前期投入成本低。
     * 缺点：采用面向过程的方式开发很难解决非常复杂的业务逻辑，面向过程的方式导致软件元素之间的“耦合度”非常高，只要其中一环出现问题，整个系统受到影响，导致最终的软件扩展能力差。另外，由于没有独立体概念，所以无法达到组件复用。
11、面向对象
    * 面向对象三个特征
     - 封装
     - 继承
     - 多态
    * 采用面向对象开发一个软件，生命周期中
     - 面向对象的分析：OOA
     - 面向对象的设计：OOD
     - 面向对象的编程：OOP
12、类和对象
    - 什么是类？
     * 类在现实世界中是不存在的，是一个模板，是一个概念，是人类大脑思考抽象的结果。
     * 类代表了一类事物。
     * 在现实世界当中，对象A与对象B之间具有共同特征，进行抽象总结出一个模板，这个模板被称为类。
    - 什么是对象？
     * 对象是实际存在的个体，现实世界当中实际存在。
    - 类-->【实例化】-->对象
    - 对象-->【抽象】-->类。
    - 对象又被成为实例
13、JVM内存空间
    - JVM主要有三块内存空间，分别是：栈内存，堆内存和方法区内存。
    - 堆内存和方法区内存各有一个，一个线程一个栈内存。
    - 栈中主要存储的是方法体当中的局部变量。
    - 方法的代码片段以及整个类的代码片段都被储存到方法区内存中，当类加载的时候这些代码片段会载入。
    - 在程序执行过程中使用new运算符创建的java对象，存储在堆内存当中，对象内部有实例变量，所以实例变量存储在堆内存当中。
    - 变量分类：
      * 局部变量【方法体中声明】
      * 成员变量（全局变量）【方法体外声明】
        * 实例变量【前边修饰符没有static】
        * 静态变量【前边修饰符有static】
    - 静态变量存储在方法区内存当中
    - 三块内存当中变化最频繁的是栈内存，最先有数据的是方法区内存，垃圾回收器主要针对的是堆内存。
14、垃圾回收器
    - 当堆内存中的java对象成为垃圾数据的时候，会被垃圾回收器回收
    - 成为垃圾的原因：
      * 没有更多的引用指向它的时候（对象只能通过引用的方式访问）。

15、封装的步骤
    1、所有属性私有化，使用private关键字修饰，修饰的所有数据只能在本类中访问。
    2、对外提供简单的操作入口：
      * 修改，调用set方法
      * 读取，调用get方法
    3、set方法命名规范：
      * public void set+首字母大写的属性名 （形参）
      public void setAge(int a){
          age = a;
      }
    4、get方法命名规范；
      * public +返回类型 get+首字母大写的属性名()
      public int getAge(){
          return age;
      }
    5、setter and getter方法没有static关键字
      - 有static关键字修饰的方法调用：类名.方法名(实参);
      - 没有static关键字的方法调用：引用.方法名（实参）;
16、继承
    - 继承的基本作用是：代码复用，但是继承最重要的作用是：有了继承才有了“方法的覆盖”和“多台机制”。
    - 继承的语法格式：
      【修饰符列表】 class 类名 extends 父类{
           类体 = 属性 + 方法
       }
    - Java语言中只支持单继承，一个类不能同时继承很多类，只能继承一个类。
    - 子类和父类可以继承哪些数据？
      * 私有的不支持继承
      * 构造方法不支持继承
      * 其他数据都可以被继承
    - 虽然Java语言当中只支持单继承，但是一个类也可以间接继承其它类，例：
      C extends B{
      }
      B extends A{
      }
      A extends T{
      }
      C直接继承B类，但是C间接继承A、T类。
    - 如果一个类没有显示的继承任何类，该类默认继承JavaSE库当中的java.lang.Object类的所有特征。
    - Java语言中任何一个类都有Object特征
17、多态
    - 多态的基本概念
      * 向上转型（upcasting）
        子类型 --> 父类型
        又被称为：自动类型转换
      * 向下转型（downcasting）
        父类型 --> 子类型
        又被称为：强制类型转换。【需要加强制类型转换符】
      * 无论是向上还是向下转型，两种类型之间必须要有继承关系。【否则无法编译通过】
    - 父类型引用指向子类型对象这种机制导致程序在编译阶段绑定和运行阶段绑定两种不同的形态、状态，这种机制可以成为一种多态语法机制、
    - 当向下转型的时候会发生强制转换，例：
       Animal a3 = new Cat();  Cat c3 = (Cat)a3;【将Animal类型引用a3转为Cat类型c3】
    - 若引用没有继承关联的对象，就会有ClassCastExcaption错误，例：
      Animal a3 = new Bird();  Cat c3 = (Cat)a3;
    - Java规范中要求：在强制类型转换之前，建议采用instanceof运算符进行判断。例：
      if(a3 instanceof Cat){ //a3是一个cat类型对象，结果为布尔类型
          Cat c3 = (Cat)a3;
          c3.catchMouse(); //cat特有行为/方法
      }else if(a3 instanceof Bird){ //a3是一个Bird类型对象
          Bird b2 = (Bird)a3;
          b2.fly(); //bird特有行为/方法
      }
18、final关键字
    - final修饰的类无法被继承
    - final修饰的方法无法被覆盖
    - final修饰的变量一旦赋值之后，不可重新赋值
    - Java语言规定实例变量使用final修饰符之后，必须手动赋值，不能使用默认值。final int age = 10;
19、常量
    - final修饰的实例变量是不可变的，一般和static联合使用，成为“常量”
    - 常用语法格式：
      public static final 类型.变量名 = 值     【Java规范中要求常量的名字全部大写，每个单词之间使用下划线连接】 例：
        public static final GUO_JI = "中国";
20、访问控制权限修饰符
    - 访问控制权限修饰符包括：
      * public  //表示公开的，在任何位置都能访问
      * protected  //同包，子类
      * default(缺省)  //同包
      * private  //表示私有的，只能在本类中访问
    - 类只能用缺省或public
21、接口
    - 定义一个接口：
      * 【修饰符】 interface 接口名{}
      * 接口中只能出现：常量和抽象类。
      * 接口就是一个特殊的抽象类，特殊在接口中是完全抽象的。
      * 接口没有构造方法，无法被实例化。
      * 接口和接口之间可以多继承。例：
        * interface A{
              void m1();
          }
          interface B{
              void m2();
          }
          interface C{
              void m3();
          }
          interface D extends A,B,C{
              void m4();
          }
      * 一个类可以实现多个接口。（这里的实现可以看作继承）。
      * 一个非抽象的类实现接口，需要将接口中的所有方法“重写/覆盖”。例：
        * class Myclass implements B,C{  //implements是实现的意思，和extends意义相同。
              public void m2(){}
              public void m3(){}
          }
        * class E implements D{
              public void m1(){}
              public void m2(){}
              public void m3(){}
              public void m4(){}
          }
22、数组(Array)
    - 数组一旦创建长度不可改变，只能扩容（再创建个数组，将原来的数组copy到新数组当中）。
    - 数组的引用指向数组中第一个元素的内存地址。
    - 数组可以通过下标快速计算出偏移量，通过首元素内存地址加上偏移量就可计算出当前元素的内存地址，通过内存地址定位到当前数组，故数组查找效率高，增删效率低。
    - Object数组：
      * Object objs = {o1, o2, o3};  Object数组存储的是引用，是对应对象的内存地址，而objs的引用指向的依然是o1在堆内存中的内存地址。
    - 一维数组的静态创建：
      * int[] a = {1, 2, 3, 4, 5};  //简化版
      * int[] a = new int[]{1, 2, 3, 4, 5};  /完整版
    - 一维数组的动态创建：
      * int[] a = new int[5]; //创建一个长度为5的数组   
    - 二维数组的静态创建：
      * int[][] a = {{1, 2}, {3, 4}};
    - 二维数组的动态创建：
      * int[][] a = new int[][]{};
23、字符串(String)
    - 由于字符串一旦创建不可改变，进而提高效率，在方法区中存储一个“字符串常量池”。相当于一个缓存区，在执行程序过程中，如果程序需要某个字符串，会现在字符串常量池中搜索该字符串，如果没有创建一个，如果有直接用。
24、StringBuffer和StringBuilder
    - StringBuffer和StringBuilder是一个字符串缓冲区。
    - 工作原理是预先在内存中申请一块空间，以容纳字符序列，如果预留的空间不够用，则自动进行扩容，以容纳更多字符。
    - StringBuffer和StringBuilder的默认初始化容量是16。
    - 若字符串频繁拼接推荐是用StringBuffer和StringBuilder
    - 两者的区别：
      * StringBuffer是线程安全的。（可以在多线程环境下使用）
      * StringBuilder是非线程安全的。

25、迭代器
    public class Exercise {
        public static void main(String[] args) {
            List list = new ArrayList();
            list.add(1);
            list.add(2);
            list.add(3);
            Iterator it = list.iterator();
            while (it.hasNext()){
                Object tmp = it.next();
                System.out.println(tmp);
            }
        }
    }
26、HashSet
    - HashSet底层是一个HashMap，HashMap底层采用哈希表数据结构。
    - 哈希表底层是一个数组，这个数组中每一个元素又是一个单向链表，每个链表有一个独一无二的hash值，代表数组的下标，在单向链表中每一个节点上的hash值时相等的。hash值时key调用hashcode方法，再通过使用hash function转换成的值。
    - 哈希表中添加元素的原理：
      * 先调用被存储key值的hashcode方法，经过某个hash算法得出hash值，如果当前哈希表中不存在这个数值，则添加元素，若已存在数值，继续调用key之间的equals方法，若返回值为true，添加元素，返回值为false，不添加元素（已存在当前元素）。
    - HashSet和HashMap的初始容量都是16，默认加载因子是0.75（存储达75%就扩容）。
    - 当创建set的时候，如果创建相同的对象填入时，由于引用地址不同，hashcode会算出不同的hash值，故而将相同的对象添加进set中，所以需要对hashcode方法重写。
27、SortedSet
    - SortedSet底层用TreeSet实现，无序不重复，并且可以对添加的元素进行排序的一个集合。
    - SortedSet不能直接对自己定义的类实现排序，需要重写compareTo方法或写一个比较器Comparetor。
28、IO流
    - 流根据方向可以分为：输入流（InputStream/Read）和输出流（OutputStream/Write）（相对内存而言）。
    - 流根据读取数据的方式可分为：字符流和字节流。字符流按照字符的方式读取，一次读取两个字节。Java语言中一个字符占两个字节。
    - 字节流适合读取：视频、声音、图片等二进制文件。字节流适合读取:纯文本文件。
    - Java语言中所有的字节流都以Stream结尾，所以的字符流都有Reader/Writer
    - FileInputStream读取文件：
      * public Test{
            public static void main(String[] args) throws Exception{
                FileInputStream file = new FileInputStream("文件地址");
                int tmp = file.read();
                System.out.println(tmp);
            }
      }
      * public Test{
            public static void main(String[] args) throws Exception{
                FileInputStream file = new FileInputStream("文件地址");
                byte[] bytes = new byte[3];  //每一次最多读取三个字节
                int tmp = file.read(bytes);  //tmp值为这一次读取的字节数
                System.out.println(new String(bytes));  //按字符串输出当前读取的字节
            }
      }


